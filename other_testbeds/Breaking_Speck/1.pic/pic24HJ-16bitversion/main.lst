CCS PCD C Compiler, Version 4.114, 93460303               04-Nov-15 17:08

               Filename: J:\onedrive_sync\CPA\Speck procedure\1.pic\pic24HJ-16bitversion\main.lst

               ROM used: 3610 bytes (16%)
                         Largest free fragment is 18918
               RAM used: 249 (6%) at main() level
                         342 (8%) worst case
               Stack:    3 locations

*
0000:  GOTO    CB6
....................  
.................... #include <24HJ32GP302.h> 
.................... //////// Standard Header file for the PIC24HJ32GP302 device //////////////// 
.................... #device PIC24HJ32GP302 
.................... #list 
....................  
....................  
.................... //configure a 8MHz crystal to operate at 8MHz 
.................... //#fuses HS,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,CPUDIV1,NOVREGEN,NOBROWNOUT 
....................   #fuses PR,XT,NOWDT,NOPROTECT,NODEBUG,NOJTAG 
....................  
.................... #pin_select U1RX=PIN_B9  
.................... #pin_select U1TX=PIN_B8  
.................... #use delay(clock=8000000) 
.................... #use rs232(UART1,baud=9600,parity=N,bits=8) 
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_B8,rcv=PIN_B9,bits=8) 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0CEA:  CLR     800
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... unsigned int64 pt[2]; 
.................... unsigned int64 ct[2]; 
.................... unsigned int64 K[2]; 
....................  
.................... unsigned int64 ans=0; 
....................  
.................... void _shiftR(unsigned int64 x,unsigned int64 r){ 
....................    ans=(x>>r); 
*
0576:  MOV     8CE,W4
0578:  PUSH    8C6
057A:  POP     836
057C:  PUSH    8C8
057E:  POP     838
0580:  PUSH    8CA
0582:  POP     83A
0584:  PUSH    8CC
0586:  POP     83C
0588:  INC     W4,W4
058A:  DEC     W4,W4
058C:  BRA     Z,598
058E:  LSR     83C
0590:  RRC     83A
0592:  RRC     838
0594:  RRC     836
0596:  BRA     58A
.................... }  
0598:  RETURN  
....................  
.................... void _shiftL(unsigned int64 x,unsigned int64 r){ 
....................    ans= (x<<r); 
059A:  MOV     8CE,W4
059C:  PUSH    8C6
059E:  POP     836
05A0:  PUSH    8C8
05A2:  POP     838
05A4:  PUSH    8CA
05A6:  POP     83A
05A8:  PUSH    8CC
05AA:  POP     83C
05AC:  INC     W4,W4
05AE:  DEC     W4,W4
05B0:  BRA     Z,5BC
05B2:  SL      836
05B4:  RLC     838
05B6:  RLC     83A
05B8:  RLC     83C
05BA:  BRA     5AE
.................... }  
05BC:  RETURN  
....................   
.................... void _or(unsigned int64 x,unsigned int64 y){ 
....................    ans= (x | y); 
05BE:  PUSH    8C4
05C0:  POP     836
05C2:  MOV     8BC,W0
05C4:  IOR     836
05C6:  PUSH    8C6
05C8:  POP     838
05CA:  MOV     8BE,W0
05CC:  IOR     838
05CE:  PUSH    8C8
05D0:  POP     83A
05D2:  MOV     8C0,W0
05D4:  IOR     83A
05D6:  PUSH    8CA
05D8:  POP     83C
05DA:  MOV     8C2,W0
05DC:  IOR     83C
.................... }  
05DE:  RETURN  
....................  
.................... void _add(unsigned int64 x,unsigned int64 y){ 
....................    ans=x+y; 
*
068E:  MOV     88C,W0
0690:  ADD     894,W0
0692:  MOV     W0,836
0694:  MOV     896,W4
0696:  MOV     88E,W3
0698:  ADDC    W3,W4,W0
069A:  MOV     W0,838
069C:  MOV     898,W4
069E:  MOV     890,W3
06A0:  ADDC    W3,W4,W0
06A2:  MOV     W0,83A
06A4:  MOV     89A,W4
06A6:  MOV     892,W3
06A8:  ADDC    W3,W4,W0
06AA:  MOV     W0,83C
.................... } 
06AC:  RETURN  
....................   
....................  
.................... void _xor(unsigned int64 x,unsigned int64 y){ 
....................    ans=x^y; 
06AE:  PUSH    894
06B0:  POP     836
06B2:  MOV     88C,W0
06B4:  XOR     836
06B6:  PUSH    896
06B8:  POP     838
06BA:  MOV     88E,W0
06BC:  XOR     838
06BE:  PUSH    898
06C0:  POP     83A
06C2:  MOV     890,W0
06C4:  XOR     83A
06C6:  PUSH    89A
06C8:  POP     83C
06CA:  MOV     892,W0
06CC:  XOR     83C
.................... } 
06CE:  RETURN  
....................  
....................  
.................... /*void _xor(unsigned int64 x,unsigned int64 y){ 
....................  
.................... #asm MY: 
....................    NOP 
....................    NOP 
....................    NOP 
....................    NOP 
....................    NOP 
....................    NOP 
....................    NOP 
....................    NOP    
....................    PUSH    0x894 
....................    NOP 
....................    NOP    
....................    POP     0x836 
....................    NOP 
....................    NOP    
....................    MOV     0x88C,W0 
....................    NOP 
....................    NOP    
....................    XOR     0x836 
....................    NOP 
....................    NOP    
....................    PUSH    0x896 
....................    NOP 
....................    NOP    
....................    POP     0x838 
....................    NOP 
....................    NOP    
....................    MOV     0x88E,W0 
....................    NOP 
....................    NOP    
....................    XOR     0x838 
....................    NOP 
....................    NOP    
....................    PUSH    0x898 
....................    NOP 
....................    NOP    
....................    POP     0x83A 
....................    NOP 
....................    NOP    
....................    MOV     0x890,W0 
....................    NOP 
....................    NOP    
....................    XOR     0x83A 
....................    NOP 
....................    NOP    
....................    PUSH    0x89A 
....................    NOP 
....................    NOP    
....................    POP     0x83C 
....................    NOP 
....................    NOP    
....................    MOV     0x892,W0 
....................    NOP 
....................    NOP    
....................    XOR     0x83C 
....................    NOP 
....................    NOP 
....................    NOP 
....................    NOP 
....................    NOP 
.................... #endasm    
....................     
....................    } */ 
....................  
....................  
.................... void ROR(unsigned int64 x, unsigned int64 r){ 
*
05E0:  MOV     W5,[W15++]
05E2:  MOV     W6,[W15++]
05E4:  MOV     W7,[W15++]
05E6:  MOV     W8,[W15++]
....................    _shiftR(x,r); 
05E8:  PUSH    88C
05EA:  POP     8C6
05EC:  PUSH    88E
05EE:  POP     8C8
05F0:  PUSH    890
05F2:  POP     8CA
05F4:  PUSH    892
05F6:  POP     8CC
05F8:  PUSH    894
05FA:  POP     8CE
05FC:  PUSH    896
05FE:  POP     8D0
0600:  PUSH    898
0602:  POP     8D2
0604:  PUSH    89A
0606:  POP     8D4
0608:  CALL    576
....................    unsigned int64 r1=ans; 
060C:  PUSH    836
060E:  POP     89C
0610:  PUSH    838
0612:  POP     89E
0614:  PUSH    83A
0616:  POP     8A0
0618:  PUSH    83C
061A:  POP     8A2
....................    _shiftL(x,64-r); 
061C:  MOV     #40,W4
061E:  MOV     894,W3
0620:  SUB     W4,W3,W5
0622:  MOV     #0,W4
0624:  MOV     896,W3
0626:  SUBB    W4,W3,W6
0628:  MOV     #0,W4
062A:  MOV     898,W3
062C:  SUBB    W4,W3,W7
062E:  MOV     #0,W4
0630:  MOV     89A,W3
0632:  SUBB    W4,W3,W8
0634:  PUSH    88C
0636:  POP     8C6
0638:  PUSH    88E
063A:  POP     8C8
063C:  PUSH    890
063E:  POP     8CA
0640:  PUSH    892
0642:  POP     8CC
0644:  MOV     W5,8CE
0646:  MOV     W6,8D0
0648:  MOV     W7,8D2
064A:  MOV     W8,8D4
064C:  CALL    59A
....................    unsigned int64 r2=ans; 
0650:  PUSH    836
0652:  POP     8A4
0654:  PUSH    838
0656:  POP     8A6
0658:  PUSH    83A
065A:  POP     8A8
065C:  PUSH    83C
065E:  POP     8AA
....................    _or(r1,r2); 
0660:  PUSH    89C
0662:  POP     8BC
0664:  PUSH    89E
0666:  POP     8BE
0668:  PUSH    8A0
066A:  POP     8C0
066C:  PUSH    8A2
066E:  POP     8C2
0670:  PUSH    8A4
0672:  POP     8C4
0674:  PUSH    8A6
0676:  POP     8C6
0678:  PUSH    8A8
067A:  POP     8C8
067C:  PUSH    8AA
067E:  POP     8CA
0680:  CALL    5BE
.................... } 
0684:  MOV     [--W15],W8
0686:  MOV     [--W15],W7
0688:  MOV     [--W15],W6
068A:  MOV     [--W15],W5
068C:  RETURN  
....................  
.................... void ROL(unsigned int64 x, unsigned int64 r){ 
*
06D0:  MOV     W5,[W15++]
06D2:  MOV     W6,[W15++]
06D4:  MOV     W7,[W15++]
06D6:  MOV     W8,[W15++]
....................    _shiftL(x,r); 
06D8:  PUSH    88C
06DA:  POP     8C6
06DC:  PUSH    88E
06DE:  POP     8C8
06E0:  PUSH    890
06E2:  POP     8CA
06E4:  PUSH    892
06E6:  POP     8CC
06E8:  PUSH    894
06EA:  POP     8CE
06EC:  PUSH    896
06EE:  POP     8D0
06F0:  PUSH    898
06F2:  POP     8D2
06F4:  PUSH    89A
06F6:  POP     8D4
06F8:  CALL    59A
....................    unsigned int64 r1=ans; 
06FC:  PUSH    836
06FE:  POP     89C
0700:  PUSH    838
0702:  POP     89E
0704:  PUSH    83A
0706:  POP     8A0
0708:  PUSH    83C
070A:  POP     8A2
....................    _shiftR(x,64-r); 
070C:  MOV     #40,W4
070E:  MOV     894,W3
0710:  SUB     W4,W3,W5
0712:  MOV     #0,W4
0714:  MOV     896,W3
0716:  SUBB    W4,W3,W6
0718:  MOV     #0,W4
071A:  MOV     898,W3
071C:  SUBB    W4,W3,W7
071E:  MOV     #0,W4
0720:  MOV     89A,W3
0722:  SUBB    W4,W3,W8
0724:  PUSH    88C
0726:  POP     8C6
0728:  PUSH    88E
072A:  POP     8C8
072C:  PUSH    890
072E:  POP     8CA
0730:  PUSH    892
0732:  POP     8CC
0734:  MOV     W5,8CE
0736:  MOV     W6,8D0
0738:  MOV     W7,8D2
073A:  MOV     W8,8D4
073C:  CALL    576
....................    unsigned int64 r2=ans; 
0740:  PUSH    836
0742:  POP     8A4
0744:  PUSH    838
0746:  POP     8A6
0748:  PUSH    83A
074A:  POP     8A8
074C:  PUSH    83C
074E:  POP     8AA
....................    _or(r1,r2); 
0750:  PUSH    89C
0752:  POP     8BC
0754:  PUSH    89E
0756:  POP     8BE
0758:  PUSH    8A0
075A:  POP     8C0
075C:  PUSH    8A2
075E:  POP     8C2
0760:  PUSH    8A4
0762:  POP     8C4
0764:  PUSH    8A6
0766:  POP     8C6
0768:  PUSH    8A8
076A:  POP     8C8
076C:  PUSH    8AA
076E:  POP     8CA
0770:  CALL    5BE
.................... } 
0774:  MOV     [--W15],W8
0776:  MOV     [--W15],W7
0778:  MOV     [--W15],W6
077A:  MOV     [--W15],W5
077C:  RETURN  
....................  
....................  
.................... void R(unsigned int64 x, unsigned int64 y, unsigned int64 k){    
....................    ROR(x,8); 
....................    x=ans; 
....................    _add(x,y); 
....................    x=ans; 
....................    _xor(x,k); 
....................    x=ans; 
....................    ROL(y,3); 
....................    y=ans; 
....................    _xor(x,y); 
....................    y=ans; 
.................... } 
....................   
.................... void encrypt(){ 
077E:  PUSH    82E
0780:  POP     87C
0782:  PUSH    830
0784:  POP     87E
0786:  PUSH    832
0788:  POP     880
078A:  PUSH    834
078C:  POP     882
078E:  PUSH    826
0790:  POP     884
0792:  PUSH    828
0794:  POP     886
0796:  PUSH    82A
0798:  POP     888
079A:  PUSH    82C
079C:  POP     88A
....................     
....................    unsigned int64 i; 
....................    unsigned int64 B = K[1]; 
....................    unsigned int64 A = K[0]; 
....................    ct[0] = pt[0];  
079E:  PUSH    806
07A0:  POP     816
07A2:  PUSH    808
07A4:  POP     818
07A6:  PUSH    80A
07A8:  POP     81A
07AA:  PUSH    80C
07AC:  POP     81C
....................    ct[1] = pt[1];    
07AE:  PUSH    80E
07B0:  POP     81E
07B2:  PUSH    810
07B4:  POP     820
07B6:  PUSH    812
07B8:  POP     822
07BA:  PUSH    814
07BC:  POP     824
....................     
....................    for(i = 0; i < 32; i++){ 
07BE:  CLR     874
07C0:  CLR     876
07C2:  CLR     878
07C4:  CLR     87A
07C6:  MOV     87A,W4
07C8:  CP      W4,#0
07CA:  BRA     GTU,9F2
07CC:  BRA     NC,7E6
07CE:  MOV     878,W4
07D0:  CP      W4,#0
07D2:  BRA     GTU,9F2
07D4:  BRA     NC,7E6
07D6:  MOV     876,W4
07D8:  CP      W4,#0
07DA:  BRA     GTU,9F2
07DC:  BRA     NC,7E6
07DE:  MOV     874,W4
07E0:  MOV     #20,W3
07E2:  CP      W3,W4
07E4:  BRA     LEU,9F2
....................  
....................       ROR(ct[1],8); 
07E6:  PUSH    81E
07E8:  POP     88C
07EA:  PUSH    820
07EC:  POP     88E
07EE:  PUSH    822
07F0:  POP     890
07F2:  PUSH    824
07F4:  POP     892
07F6:  MOV     #8,W4
07F8:  MOV     W4,894
07FA:  CLR     896
07FC:  CLR     898
07FE:  CLR     89A
0800:  CALL    5E0
....................       ct[1]=ans; 
0804:  PUSH    836
0806:  POP     81E
0808:  PUSH    838
080A:  POP     820
080C:  PUSH    83A
080E:  POP     822
0810:  PUSH    83C
0812:  POP     824
....................       _add(ct[1],ct[0]); 
0814:  PUSH    81E
0816:  POP     88C
0818:  PUSH    820
081A:  POP     88E
081C:  PUSH    822
081E:  POP     890
0820:  PUSH    824
0822:  POP     892
0824:  PUSH    816
0826:  POP     894
0828:  PUSH    818
082A:  POP     896
082C:  PUSH    81A
082E:  POP     898
0830:  PUSH    81C
0832:  POP     89A
0834:  CALL    68E
....................       ct[1]=ans; 
0838:  PUSH    836
083A:  POP     81E
083C:  PUSH    838
083E:  POP     820
0840:  PUSH    83A
0842:  POP     822
0844:  PUSH    83C
0846:  POP     824
....................       
....................       _xor(ct[1],A);  
0848:  PUSH    81E
084A:  POP     88C
084C:  PUSH    820
084E:  POP     88E
0850:  PUSH    822
0852:  POP     890
0854:  PUSH    824
0856:  POP     892
0858:  PUSH    884
085A:  POP     894
085C:  PUSH    886
085E:  POP     896
0860:  PUSH    888
0862:  POP     898
0864:  PUSH    88A
0866:  POP     89A
0868:  CALL    6AE
....................        
....................       delay_ms(1); 
086C:  REPEAT  #F9E
086E:  NOP     
....................       if(i==0){ 
0870:  CP0     874
0872:  BRA     NZ,884
0874:  CP0     876
0876:  BRA     NZ,884
0878:  CP0     878
087A:  BRA     NZ,884
087C:  CP0     87A
087E:  BRA     NZ,884
....................          output_high (PIN_B0); 
0880:  BCLR.B  2C8.0
0882:  BSET.B  2CC.0
....................       } 
....................       /*if(i==1){ 
....................          output_high (PIN_B1); 
....................       } */  
....................        
....................       ct[1]=ans; 
0884:  PUSH    836
0886:  POP     81E
0888:  PUSH    838
088A:  POP     820
088C:  PUSH    83A
088E:  POP     822
0890:  PUSH    83C
0892:  POP     824
....................        
....................       ROL(ct[0],3); 
0894:  PUSH    816
0896:  POP     88C
0898:  PUSH    818
089A:  POP     88E
089C:  PUSH    81A
089E:  POP     890
08A0:  PUSH    81C
08A2:  POP     892
08A4:  MOV     #3,W4
08A6:  MOV     W4,894
08A8:  CLR     896
08AA:  CLR     898
08AC:  CLR     89A
08AE:  CALL    6D0
....................       ct[0]=ans; 
08B2:  PUSH    836
08B4:  POP     816
08B6:  PUSH    838
08B8:  POP     818
08BA:  PUSH    83A
08BC:  POP     81A
08BE:  PUSH    83C
08C0:  POP     81C
....................             
....................       ct[0]=ct[1]^ct[0]; 
08C2:  MOV     81E,W0
08C4:  XOR     816
08C6:  MOV     820,W0
08C8:  XOR     818
08CA:  MOV     822,W0
08CC:  XOR     81A
08CE:  MOV     824,W0
08D0:  XOR     81C
....................        
....................       if(i==0){ 
08D2:  CP0     874
08D4:  BRA     NZ,8E6
08D6:  CP0     876
08D8:  BRA     NZ,8E6
08DA:  CP0     878
08DC:  BRA     NZ,8E6
08DE:  CP0     87A
08E0:  BRA     NZ,8E6
....................          output_low (PIN_B0); 
08E2:  BCLR.B  2C8.0
08E4:  BCLR.B  2CC.0
....................       } 
....................       /*if(i==1){ 
....................          output_low (PIN_B1); 
....................       } */  
....................       delay_ms(1); 
08E6:  REPEAT  #F9E
08E8:  NOP     
....................        
....................       ROR(B,8); 
08EA:  PUSH    87C
08EC:  POP     88C
08EE:  PUSH    87E
08F0:  POP     88E
08F2:  PUSH    880
08F4:  POP     890
08F6:  PUSH    882
08F8:  POP     892
08FA:  MOV     #8,W4
08FC:  MOV     W4,894
08FE:  CLR     896
0900:  CLR     898
0902:  CLR     89A
0904:  CALL    5E0
....................       B=ans; 
0908:  PUSH    836
090A:  POP     87C
090C:  PUSH    838
090E:  POP     87E
0910:  PUSH    83A
0912:  POP     880
0914:  PUSH    83C
0916:  POP     882
....................  
....................       _add(B,A); 
0918:  PUSH    87C
091A:  POP     88C
091C:  PUSH    87E
091E:  POP     88E
0920:  PUSH    880
0922:  POP     890
0924:  PUSH    882
0926:  POP     892
0928:  PUSH    884
092A:  POP     894
092C:  PUSH    886
092E:  POP     896
0930:  PUSH    888
0932:  POP     898
0934:  PUSH    88A
0936:  POP     89A
0938:  CALL    68E
....................       B=ans; 
093C:  PUSH    836
093E:  POP     87C
0940:  PUSH    838
0942:  POP     87E
0944:  PUSH    83A
0946:  POP     880
0948:  PUSH    83C
094A:  POP     882
....................     
....................       _xor(B,i); 
094C:  PUSH    87C
094E:  POP     88C
0950:  PUSH    87E
0952:  POP     88E
0954:  PUSH    880
0956:  POP     890
0958:  PUSH    882
095A:  POP     892
095C:  PUSH    874
095E:  POP     894
0960:  PUSH    876
0962:  POP     896
0964:  PUSH    878
0966:  POP     898
0968:  PUSH    87A
096A:  POP     89A
096C:  CALL    6AE
....................       B=ans; 
0970:  PUSH    836
0972:  POP     87C
0974:  PUSH    838
0976:  POP     87E
0978:  PUSH    83A
097A:  POP     880
097C:  PUSH    83C
097E:  POP     882
....................     
....................       ROL(A,3); 
0980:  PUSH    884
0982:  POP     88C
0984:  PUSH    886
0986:  POP     88E
0988:  PUSH    888
098A:  POP     890
098C:  PUSH    88A
098E:  POP     892
0990:  MOV     #3,W4
0992:  MOV     W4,894
0994:  CLR     896
0996:  CLR     898
0998:  CLR     89A
099A:  CALL    6D0
....................       A=ans; 
099E:  PUSH    836
09A0:  POP     884
09A2:  PUSH    838
09A4:  POP     886
09A6:  PUSH    83A
09A8:  POP     888
09AA:  PUSH    83C
09AC:  POP     88A
....................       _xor(B,A); 
09AE:  PUSH    87C
09B0:  POP     88C
09B2:  PUSH    87E
09B4:  POP     88E
09B6:  PUSH    880
09B8:  POP     890
09BA:  PUSH    882
09BC:  POP     892
09BE:  PUSH    884
09C0:  POP     894
09C2:  PUSH    886
09C4:  POP     896
09C6:  PUSH    888
09C8:  POP     898
09CA:  PUSH    88A
09CC:  POP     89A
09CE:  CALL    6AE
....................       A=ans; 
09D2:  PUSH    836
09D4:  POP     884
09D6:  PUSH    838
09D8:  POP     886
09DA:  PUSH    83A
09DC:  POP     888
09DE:  PUSH    83C
09E0:  POP     88A
....................              
....................    } 
09E2:  INC     0874
09E4:  BTSC.B  42.1
09E6:  INC     0876
09E8:  BTSC.B  42.1
09EA:  INC     0878
09EC:  BTSC.B  42.1
09EE:  INC     087A
09F0:  BRA     7C6
.................... } 
09F2:  RETURN  
....................   
....................  void convert(unsigned char block[],unsigned int64 ct[]){ 
09F4:  MOV     W5,[W15++]
09F6:  MOV     #C,W5
09F8:  REPEAT  #3
09FA:  MOV     [W5++],[W15++]
....................   block[0] = (unsigned char) ((ct[0] >> 56)& (unsigned int64)0xFF); 
09FC:  MOV     #0,W0
09FE:  ADD     878,W0
0A00:  MOV     W0,W5
0A02:  MOV     #0,W0
0A04:  ADD     87A,W0
0A06:  MOV     #C,W4
0A08:  REPEAT  #3
0A0A:  MOV     [W0++],[W4++]
0A0C:  MOV.B   13,W0L
0A0E:  MOV.B   W0L,W6L
0A10:  CLR.B   D
0A12:  CLR.B   W7
0A14:  CLR.B   F
0A16:  CLR.B   W8
0A18:  CLR.B   11
0A1A:  CLR.B   W9
0A1C:  CLR.B   13
0A1E:  CLR     W3
0A20:  CLR     W2
0A22:  CLR     W1
0A24:  MOV     W6,W0
0A26:  AND     #FF,W0
0A28:  MOV.B   W0L,[W5]
....................   block[1] = (unsigned char) ((ct[0] >> 48)& (unsigned int64)0xFF); 
0A2A:  MOV     #1,W0
0A2C:  ADD     878,W0
0A2E:  MOV     W0,W5
0A30:  MOV     #0,W0
0A32:  ADD     87A,W0
0A34:  MOV     #C,W4
0A36:  REPEAT  #3
0A38:  MOV     [W0++],[W4++]
0A3A:  MOV     W9,W6
0A3C:  MOV     #0,W7
0A3E:  MOV     #0,W8
0A40:  MOV     #0,W9
0A42:  CLR     W3
0A44:  CLR     W2
0A46:  CLR     W1
0A48:  MOV     W6,W0
0A4A:  AND     #FF,W0
0A4C:  MOV.B   W0L,[W5]
....................   block[2] = (unsigned char) ((ct[0] >> 40)& (unsigned int64)0xFF); 
0A4E:  MOV     #2,W0
0A50:  ADD     878,W0
0A52:  MOV     W0,W5
0A54:  MOV     #0,W0
0A56:  ADD     87A,W0
0A58:  MOV     #C,W4
0A5A:  REPEAT  #3
0A5C:  MOV     [W0++],[W4++]
0A5E:  MOV.B   11,W0L
0A60:  MOV.B   W0L,W6L
0A62:  MOV.B   W9L,W0L
0A64:  MOV.B   W0L,D
0A66:  MOV.B   13,W0L
0A68:  MOV.B   W0L,W7L
0A6A:  CLR.B   F
0A6C:  CLR.B   W8
0A6E:  CLR.B   11
0A70:  CLR.B   W9
0A72:  CLR.B   13
0A74:  CLR     W3
0A76:  CLR     W2
0A78:  CLR     W1
0A7A:  MOV     W6,W0
0A7C:  AND     #FF,W0
0A7E:  MOV.B   W0L,[W5]
....................   block[3] = (unsigned char) ((ct[0] >> 32)& (unsigned int64)0xFF); 
0A80:  MOV     #3,W0
0A82:  ADD     878,W0
0A84:  MOV     W0,W5
0A86:  MOV     #0,W0
0A88:  ADD     87A,W0
0A8A:  MOV     #C,W4
0A8C:  REPEAT  #3
0A8E:  MOV     [W0++],[W4++]
0A90:  MOV     W8,W6
0A92:  MOV     W9,W7
0A94:  MOV     #0,W8
0A96:  MOV     #0,W9
0A98:  CLR     W3
0A9A:  CLR     W2
0A9C:  CLR     W1
0A9E:  MOV     W6,W0
0AA0:  AND     #FF,W0
0AA2:  MOV.B   W0L,[W5]
....................   block[4] = (unsigned char) ((ct[0] >> 24)& (unsigned int64)0xFF); 
0AA4:  MOV     #4,W0
0AA6:  ADD     878,W0
0AA8:  MOV     W0,W5
0AAA:  MOV     #0,W0
0AAC:  ADD     87A,W0
0AAE:  MOV     #C,W4
0AB0:  REPEAT  #3
0AB2:  MOV     [W0++],[W4++]
0AB4:  MOV.B   F,W0L
0AB6:  MOV.B   W0L,W6L
0AB8:  MOV.B   W8L,W0L
0ABA:  MOV.B   W0L,D
0ABC:  MOV.B   11,W0L
0ABE:  MOV.B   W0L,W7L
0AC0:  MOV.B   W9L,W0L
0AC2:  MOV.B   W0L,F
0AC4:  MOV.B   13,W0L
0AC6:  MOV.B   W0L,W8L
0AC8:  CLR.B   11
0ACA:  CLR.B   W9
0ACC:  CLR.B   13
0ACE:  CLR     W3
0AD0:  CLR     W2
0AD2:  CLR     W1
0AD4:  MOV     W6,W0
0AD6:  AND     #FF,W0
0AD8:  MOV.B   W0L,[W5]
....................   block[5] = (unsigned char) ((ct[0] >> 16)& (unsigned int64)0xFF); 
0ADA:  MOV     #5,W0
0ADC:  ADD     878,W0
0ADE:  MOV     W0,W5
0AE0:  MOV     #0,W0
0AE2:  ADD     87A,W0
0AE4:  MOV     #C,W4
0AE6:  REPEAT  #3
0AE8:  MOV     [W0++],[W4++]
0AEA:  MOV     W7,W6
0AEC:  MOV     W8,W7
0AEE:  MOV     W9,W8
0AF0:  MOV     #0,W9
0AF2:  CLR     W3
0AF4:  CLR     W2
0AF6:  CLR     W1
0AF8:  MOV     W6,W0
0AFA:  AND     #FF,W0
0AFC:  MOV.B   W0L,[W5]
....................   block[6] = (unsigned char) ((ct[0] >> 8)& (unsigned int64)0xFF); 
0AFE:  MOV     #6,W0
0B00:  ADD     878,W0
0B02:  MOV     W0,W5
0B04:  MOV     #0,W0
0B06:  ADD     87A,W0
0B08:  MOV     #C,W4
0B0A:  REPEAT  #3
0B0C:  MOV     [W0++],[W4++]
0B0E:  MOV.B   D,W0L
0B10:  MOV.B   W0L,W6L
0B12:  MOV.B   W7L,W0L
0B14:  MOV.B   W0L,D
0B16:  MOV.B   F,W0L
0B18:  MOV.B   W0L,W7L
0B1A:  MOV.B   W8L,W0L
0B1C:  MOV.B   W0L,F
0B1E:  MOV.B   11,W0L
0B20:  MOV.B   W0L,W8L
0B22:  MOV.B   W9L,W0L
0B24:  MOV.B   W0L,11
0B26:  MOV.B   13,W0L
0B28:  MOV.B   W0L,W9L
0B2A:  CLR.B   13
0B2C:  CLR     W3
0B2E:  CLR     W2
0B30:  CLR     W1
0B32:  MOV     W6,W0
0B34:  AND     #FF,W0
0B36:  MOV.B   W0L,[W5]
....................   block[7] = (unsigned char) ((ct[0])& (unsigned int64)0xFF);   
0B38:  MOV     #7,W0
0B3A:  ADD     878,W0
0B3C:  MOV     W0,W5
0B3E:  MOV     #0,W0
0B40:  ADD     87A,W0
0B42:  MOV     #C,W4
0B44:  REPEAT  #3
0B46:  MOV     [W0++],[W4++]
0B48:  CLR     W3
0B4A:  CLR     W2
0B4C:  CLR     W1
0B4E:  MOV     W6,W0
0B50:  AND     #FF,W0
0B52:  MOV.B   W0L,[W5]
....................    
....................   block[8] = (unsigned char) ((ct[1] >> 56)& (unsigned int64)0xFF); 
0B54:  MOV     #8,W0
0B56:  ADD     878,W0
0B58:  MOV     W0,W5
0B5A:  MOV     #8,W0
0B5C:  ADD     87A,W0
0B5E:  MOV     #C,W4
0B60:  REPEAT  #3
0B62:  MOV     [W0++],[W4++]
0B64:  MOV.B   13,W0L
0B66:  MOV.B   W0L,W6L
0B68:  CLR.B   D
0B6A:  CLR.B   W7
0B6C:  CLR.B   F
0B6E:  CLR.B   W8
0B70:  CLR.B   11
0B72:  CLR.B   W9
0B74:  CLR.B   13
0B76:  CLR     W3
0B78:  CLR     W2
0B7A:  CLR     W1
0B7C:  MOV     W6,W0
0B7E:  AND     #FF,W0
0B80:  MOV.B   W0L,[W5]
....................   block[9] = (unsigned char) ((ct[1] >> 48)& (unsigned int64)0xFF); 
0B82:  MOV     #9,W0
0B84:  ADD     878,W0
0B86:  MOV     W0,W5
0B88:  MOV     #8,W0
0B8A:  ADD     87A,W0
0B8C:  MOV     #C,W4
0B8E:  REPEAT  #3
0B90:  MOV     [W0++],[W4++]
0B92:  MOV     W9,W6
0B94:  MOV     #0,W7
0B96:  MOV     #0,W8
0B98:  MOV     #0,W9
0B9A:  CLR     W3
0B9C:  CLR     W2
0B9E:  CLR     W1
0BA0:  MOV     W6,W0
0BA2:  AND     #FF,W0
0BA4:  MOV.B   W0L,[W5]
....................   block[10] = (unsigned char)((ct[1] >> 40)& (unsigned int64)0xFF); 
0BA6:  MOV     #A,W0
0BA8:  ADD     878,W0
0BAA:  MOV     W0,W5
0BAC:  MOV     #8,W0
0BAE:  ADD     87A,W0
0BB0:  MOV     #C,W4
0BB2:  REPEAT  #3
0BB4:  MOV     [W0++],[W4++]
0BB6:  MOV.B   11,W0L
0BB8:  MOV.B   W0L,W6L
0BBA:  MOV.B   W9L,W0L
0BBC:  MOV.B   W0L,D
0BBE:  MOV.B   13,W0L
0BC0:  MOV.B   W0L,W7L
0BC2:  CLR.B   F
0BC4:  CLR.B   W8
0BC6:  CLR.B   11
0BC8:  CLR.B   W9
0BCA:  CLR.B   13
0BCC:  CLR     W3
0BCE:  CLR     W2
0BD0:  CLR     W1
0BD2:  MOV     W6,W0
0BD4:  AND     #FF,W0
0BD6:  MOV.B   W0L,[W5]
....................   block[11] = (unsigned char)((ct[1] >> 32)& (unsigned int64)0xFF); 
0BD8:  MOV     #B,W0
0BDA:  ADD     878,W0
0BDC:  MOV     W0,W5
0BDE:  MOV     #8,W0
0BE0:  ADD     87A,W0
0BE2:  MOV     #C,W4
0BE4:  REPEAT  #3
0BE6:  MOV     [W0++],[W4++]
0BE8:  MOV     W8,W6
0BEA:  MOV     W9,W7
0BEC:  MOV     #0,W8
0BEE:  MOV     #0,W9
0BF0:  CLR     W3
0BF2:  CLR     W2
0BF4:  CLR     W1
0BF6:  MOV     W6,W0
0BF8:  AND     #FF,W0
0BFA:  MOV.B   W0L,[W5]
....................   block[12] = (unsigned char)((ct[1] >> 24)& (unsigned int64)0xFF); 
0BFC:  MOV     #C,W0
0BFE:  ADD     878,W0
0C00:  MOV     W0,W5
0C02:  MOV     #8,W0
0C04:  ADD     87A,W0
0C06:  MOV     #C,W4
0C08:  REPEAT  #3
0C0A:  MOV     [W0++],[W4++]
0C0C:  MOV.B   F,W0L
0C0E:  MOV.B   W0L,W6L
0C10:  MOV.B   W8L,W0L
0C12:  MOV.B   W0L,D
0C14:  MOV.B   11,W0L
0C16:  MOV.B   W0L,W7L
0C18:  MOV.B   W9L,W0L
0C1A:  MOV.B   W0L,F
0C1C:  MOV.B   13,W0L
0C1E:  MOV.B   W0L,W8L
0C20:  CLR.B   11
0C22:  CLR.B   W9
0C24:  CLR.B   13
0C26:  CLR     W3
0C28:  CLR     W2
0C2A:  CLR     W1
0C2C:  MOV     W6,W0
0C2E:  AND     #FF,W0
0C30:  MOV.B   W0L,[W5]
....................   block[13] = (unsigned char)((ct[1] >> 16)& (unsigned int64)0xFF); 
0C32:  MOV     #D,W0
0C34:  ADD     878,W0
0C36:  MOV     W0,W5
0C38:  MOV     #8,W0
0C3A:  ADD     87A,W0
0C3C:  MOV     #C,W4
0C3E:  REPEAT  #3
0C40:  MOV     [W0++],[W4++]
0C42:  MOV     W7,W6
0C44:  MOV     W8,W7
0C46:  MOV     W9,W8
0C48:  MOV     #0,W9
0C4A:  CLR     W3
0C4C:  CLR     W2
0C4E:  CLR     W1
0C50:  MOV     W6,W0
0C52:  AND     #FF,W0
0C54:  MOV.B   W0L,[W5]
....................   block[14] = (unsigned char)((ct[1] >> 8)& (unsigned int64)0xFF); 
0C56:  MOV     #E,W0
0C58:  ADD     878,W0
0C5A:  MOV     W0,W5
0C5C:  MOV     #8,W0
0C5E:  ADD     87A,W0
0C60:  MOV     #C,W4
0C62:  REPEAT  #3
0C64:  MOV     [W0++],[W4++]
0C66:  MOV.B   D,W0L
0C68:  MOV.B   W0L,W6L
0C6A:  MOV.B   W7L,W0L
0C6C:  MOV.B   W0L,D
0C6E:  MOV.B   F,W0L
0C70:  MOV.B   W0L,W7L
0C72:  MOV.B   W8L,W0L
0C74:  MOV.B   W0L,F
0C76:  MOV.B   11,W0L
0C78:  MOV.B   W0L,W8L
0C7A:  MOV.B   W9L,W0L
0C7C:  MOV.B   W0L,11
0C7E:  MOV.B   13,W0L
0C80:  MOV.B   W0L,W9L
0C82:  CLR.B   13
0C84:  CLR     W3
0C86:  CLR     W2
0C88:  CLR     W1
0C8A:  MOV     W6,W0
0C8C:  AND     #FF,W0
0C8E:  MOV.B   W0L,[W5]
....................   block[15] = (unsigned char)((ct[1]) & (unsigned int64)0xFF);  
0C90:  MOV     #F,W0
0C92:  ADD     878,W0
0C94:  MOV     W0,W5
0C96:  MOV     #8,W0
0C98:  ADD     87A,W0
0C9A:  MOV     #C,W4
0C9C:  REPEAT  #3
0C9E:  MOV     [W0++],[W4++]
0CA0:  CLR     W3
0CA2:  CLR     W2
0CA4:  CLR     W1
0CA6:  MOV     W6,W0
0CA8:  AND     #FF,W0
0CAA:  MOV.B   W0L,[W5]
.................... } 
0CAC:  MOV     #12,W5
0CAE:  REPEAT  #3
0CB0:  MOV     [--W15],[W5--]
0CB2:  MOV     [--W15],W5
0CB4:  RETURN  
....................  
....................  void convertback(unsigned int64 ct[],unsigned char block[]){ 
*
0308:  MOV     W5,[W15++]
030A:  MOV     #C,W5
030C:  REPEAT  #7
030E:  MOV     [W5++],[W15++]
....................     ct[0]= (((unsigned int64)block[0])<<56) | (((unsigned int64)block[1])<<48) | (((unsigned int64)block[2])<<40) | (((unsigned int64)block[3])<<32) | (((unsigned int64)block[4])<<24) | (((unsigned int64)block[5])<<16) | (((unsigned int64)block[6])<<8) | (((unsigned int64)block[7]));  
0310:  MOV     #0,W0
0312:  ADD     878,W0
0314:  MOV     W0,W5
0316:  MOV     #0,W0
0318:  ADD     87A,W0
031A:  MOV.B   [W0],W6L
031C:  CLR.B   D
031E:  MOV     #0,W7
0320:  MOV     #0,W8
0322:  MOV     #0,W9
0324:  MOV.B   W6L,W0L
0326:  MOV.B   W0L,13
0328:  CLR.B   W9
032A:  CLR.B   11
032C:  CLR.B   W8
032E:  CLR.B   F
0330:  CLR.B   W7
0332:  CLR.B   D
0334:  CLR.B   W6
0336:  MOV     #1,W0
0338:  ADD     87A,W0
033A:  MOV.B   [W0],W10L
033C:  CLR.B   15
033E:  MOV     #0,W11
0340:  MOV     #0,W12
0342:  MOV     #0,W13
0344:  MOV     W10,W3
0346:  MOV     #0,W2
0348:  MOV     #0,W1
034A:  MOV     #0,W0
034C:  IOR      W6,  W0,W6
034E:  IOR      W7,  W1,W7
0350:  IOR      W8,  W2,W8
0352:  IOR      W9,  W3,W9
0354:  MOV     #2,W0
0356:  ADD     87A,W0
0358:  MOV.B   [W0],W10L
035A:  CLR.B   15
035C:  MOV     #0,W11
035E:  MOV     #0,W12
0360:  MOV     #0,W13
0362:  MOV.B   W11L,W0L
0364:  MOV.B   W0L,7
0366:  MOV.B   15,W0L
0368:  MOV.B   W0L,W3L
036A:  MOV.B   W10L,W0L
036C:  MOV.B   W0L,5
036E:  CLR.B   W2
0370:  CLR.B   3
0372:  CLR.B   W1
0374:  CLR.B   1
0376:  CLR.B   W0
0378:  IOR      W6,  W0,W6
037A:  IOR      W7,  W1,W7
037C:  IOR      W8,  W2,W8
037E:  IOR      W9,  W3,W9
0380:  MOV     #3,W0
0382:  ADD     87A,W0
0384:  MOV.B   [W0],W10L
0386:  CLR.B   15
0388:  MOV     #0,W11
038A:  MOV     #0,W12
038C:  MOV     #0,W13
038E:  MOV     W11,W3
0390:  MOV     W10,W2
0392:  MOV     #0,W1
0394:  MOV     #0,W0
0396:  IOR      W6,  W0,W6
0398:  IOR      W7,  W1,W7
039A:  IOR      W8,  W2,W8
039C:  IOR      W9,  W3,W9
039E:  MOV     #4,W0
03A0:  ADD     87A,W0
03A2:  MOV.B   [W0],W10L
03A4:  CLR.B   15
03A6:  MOV     #0,W11
03A8:  MOV     #0,W12
03AA:  MOV     #0,W13
03AC:  MOV.B   W12L,W0L
03AE:  MOV.B   W0L,7
03B0:  MOV.B   17,W0L
03B2:  MOV.B   W0L,W3L
03B4:  MOV.B   W11L,W0L
03B6:  MOV.B   W0L,5
03B8:  MOV.B   15,W0L
03BA:  MOV.B   W0L,W2L
03BC:  MOV.B   W10L,W0L
03BE:  MOV.B   W0L,3
03C0:  CLR.B   W1
03C2:  CLR.B   1
03C4:  CLR.B   W0
03C6:  IOR      W6,  W0,W6
03C8:  IOR      W7,  W1,W7
03CA:  IOR      W8,  W2,W8
03CC:  IOR      W9,  W3,W9
03CE:  MOV     #5,W0
03D0:  ADD     87A,W0
03D2:  MOV.B   [W0],W10L
03D4:  CLR.B   15
03D6:  MOV     #0,W11
03D8:  MOV     #0,W12
03DA:  MOV     #0,W13
03DC:  MOV     W12,W3
03DE:  MOV     W11,W2
03E0:  MOV     W10,W1
03E2:  MOV     #0,W0
03E4:  IOR      W6,  W0,W6
03E6:  IOR      W7,  W1,W7
03E8:  IOR      W8,  W2,W8
03EA:  IOR      W9,  W3,W9
03EC:  MOV     #6,W0
03EE:  ADD     87A,W0
03F0:  MOV.B   [W0],W10L
03F2:  CLR.B   15
03F4:  MOV     #0,W11
03F6:  MOV     #0,W12
03F8:  MOV     #0,W13
03FA:  MOV.B   W13L,W0L
03FC:  MOV.B   W0L,7
03FE:  MOV.B   19,W0L
0400:  MOV.B   W0L,W3L
0402:  MOV.B   W12L,W0L
0404:  MOV.B   W0L,5
0406:  MOV.B   17,W0L
0408:  MOV.B   W0L,W2L
040A:  MOV.B   W11L,W0L
040C:  MOV.B   W0L,3
040E:  MOV.B   15,W0L
0410:  MOV.B   W0L,W1L
0412:  MOV.B   W10L,W0L
0414:  MOV.B   W0L,1
0416:  CLR.B   W0
0418:  IOR      W6,  W0,W6
041A:  IOR      W7,  W1,W7
041C:  IOR      W8,  W2,W8
041E:  IOR      W9,  W3,W9
0420:  MOV     #7,W0
0422:  ADD     87A,W0
0424:  MOV     W0,W4
0426:  MOV.B   [W4],W0L
0428:  CLR.B   1
042A:  MOV     #0,W1
042C:  MOV     #0,W2
042E:  MOV     #0,W3
0430:  IOR      W9,  W3,W3
0432:  IOR      W8,  W2,W2
0434:  IOR      W7,  W1,W1
0436:  IOR      W6,  W0,W0
0438:  MOV     #0,W4
043A:  REPEAT  #3
043C:  MOV     [W4++],[W5++]
....................     ct[1]= (((unsigned int64)block[8])<<56) | (((unsigned int64)block[9])<<48) | (((unsigned int64)block[10])<<40) | (((unsigned int64)block[11])<<32) | (((unsigned int64)block[12])<<24) | (((unsigned int64)block[13])<<16) | (((unsigned int64)block[14])<<8) | (((unsigned int64)block[15])) ; 
043E:  MOV     #8,W0
0440:  ADD     878,W0
0442:  MOV     W0,W5
0444:  MOV     #8,W0
0446:  ADD     87A,W0
0448:  MOV.B   [W0],W6L
044A:  CLR.B   D
044C:  MOV     #0,W7
044E:  MOV     #0,W8
0450:  MOV     #0,W9
0452:  MOV.B   W6L,W0L
0454:  MOV.B   W0L,13
0456:  CLR.B   W9
0458:  CLR.B   11
045A:  CLR.B   W8
045C:  CLR.B   F
045E:  CLR.B   W7
0460:  CLR.B   D
0462:  CLR.B   W6
0464:  MOV     #9,W0
0466:  ADD     87A,W0
0468:  MOV.B   [W0],W10L
046A:  CLR.B   15
046C:  MOV     #0,W11
046E:  MOV     #0,W12
0470:  MOV     #0,W13
0472:  MOV     W10,W3
0474:  MOV     #0,W2
0476:  MOV     #0,W1
0478:  MOV     #0,W0
047A:  IOR      W6,  W0,W6
047C:  IOR      W7,  W1,W7
047E:  IOR      W8,  W2,W8
0480:  IOR      W9,  W3,W9
0482:  MOV     #A,W0
0484:  ADD     87A,W0
0486:  MOV.B   [W0],W10L
0488:  CLR.B   15
048A:  MOV     #0,W11
048C:  MOV     #0,W12
048E:  MOV     #0,W13
0490:  MOV.B   W11L,W0L
0492:  MOV.B   W0L,7
0494:  MOV.B   15,W0L
0496:  MOV.B   W0L,W3L
0498:  MOV.B   W10L,W0L
049A:  MOV.B   W0L,5
049C:  CLR.B   W2
049E:  CLR.B   3
04A0:  CLR.B   W1
04A2:  CLR.B   1
04A4:  CLR.B   W0
04A6:  IOR      W6,  W0,W6
04A8:  IOR      W7,  W1,W7
04AA:  IOR      W8,  W2,W8
04AC:  IOR      W9,  W3,W9
04AE:  MOV     #B,W0
04B0:  ADD     87A,W0
04B2:  MOV.B   [W0],W10L
04B4:  CLR.B   15
04B6:  MOV     #0,W11
04B8:  MOV     #0,W12
04BA:  MOV     #0,W13
04BC:  MOV     W11,W3
04BE:  MOV     W10,W2
04C0:  MOV     #0,W1
04C2:  MOV     #0,W0
04C4:  IOR      W6,  W0,W6
04C6:  IOR      W7,  W1,W7
04C8:  IOR      W8,  W2,W8
04CA:  IOR      W9,  W3,W9
04CC:  MOV     #C,W0
04CE:  ADD     87A,W0
04D0:  MOV.B   [W0],W10L
04D2:  CLR.B   15
04D4:  MOV     #0,W11
04D6:  MOV     #0,W12
04D8:  MOV     #0,W13
04DA:  MOV.B   W12L,W0L
04DC:  MOV.B   W0L,7
04DE:  MOV.B   17,W0L
04E0:  MOV.B   W0L,W3L
04E2:  MOV.B   W11L,W0L
04E4:  MOV.B   W0L,5
04E6:  MOV.B   15,W0L
04E8:  MOV.B   W0L,W2L
04EA:  MOV.B   W10L,W0L
04EC:  MOV.B   W0L,3
04EE:  CLR.B   W1
04F0:  CLR.B   1
04F2:  CLR.B   W0
04F4:  IOR      W6,  W0,W6
04F6:  IOR      W7,  W1,W7
04F8:  IOR      W8,  W2,W8
04FA:  IOR      W9,  W3,W9
04FC:  MOV     #D,W0
04FE:  ADD     87A,W0
0500:  MOV.B   [W0],W10L
0502:  CLR.B   15
0504:  MOV     #0,W11
0506:  MOV     #0,W12
0508:  MOV     #0,W13
050A:  MOV     W12,W3
050C:  MOV     W11,W2
050E:  MOV     W10,W1
0510:  MOV     #0,W0
0512:  IOR      W6,  W0,W6
0514:  IOR      W7,  W1,W7
0516:  IOR      W8,  W2,W8
0518:  IOR      W9,  W3,W9
051A:  MOV     #E,W0
051C:  ADD     87A,W0
051E:  MOV.B   [W0],W10L
0520:  CLR.B   15
0522:  MOV     #0,W11
0524:  MOV     #0,W12
0526:  MOV     #0,W13
0528:  MOV.B   W13L,W0L
052A:  MOV.B   W0L,7
052C:  MOV.B   19,W0L
052E:  MOV.B   W0L,W3L
0530:  MOV.B   W12L,W0L
0532:  MOV.B   W0L,5
0534:  MOV.B   17,W0L
0536:  MOV.B   W0L,W2L
0538:  MOV.B   W11L,W0L
053A:  MOV.B   W0L,3
053C:  MOV.B   15,W0L
053E:  MOV.B   W0L,W1L
0540:  MOV.B   W10L,W0L
0542:  MOV.B   W0L,1
0544:  CLR.B   W0
0546:  IOR      W6,  W0,W6
0548:  IOR      W7,  W1,W7
054A:  IOR      W8,  W2,W8
054C:  IOR      W9,  W3,W9
054E:  MOV     #F,W0
0550:  ADD     87A,W0
0552:  MOV     W0,W4
0554:  MOV.B   [W4],W0L
0556:  CLR.B   1
0558:  MOV     #0,W1
055A:  MOV     #0,W2
055C:  MOV     #0,W3
055E:  IOR      W9,  W3,W3
0560:  IOR      W8,  W2,W2
0562:  IOR      W7,  W1,W1
0564:  IOR      W6,  W0,W0
0566:  MOV     #0,W4
0568:  REPEAT  #3
056A:  MOV     [W4++],[W5++]
.................... } 
056C:  MOV     #1A,W5
056E:  REPEAT  #7
0570:  MOV     [--W15],[W5--]
0572:  MOV     [--W15],W5
0574:  RETURN  
....................  
.................... void convertbyte(unsigned char block[16],unsigned int64 ct){ 
....................   block[0] = (unsigned char) (ct >> 56); 
....................   block[1] = (unsigned char) (ct >> 48); 
....................   block[2] = (unsigned char) (ct >> 40); 
....................   block[3] = (unsigned char) (ct >> 32); 
....................   block[4] = (unsigned char) (ct >> 24); 
....................   block[5] = (unsigned char) (ct >> 16); 
....................   block[6] = (unsigned char) (ct >> 8); 
....................   block[7] = (unsigned char) (ct);   
....................   
.................... } 
....................  
....................  
.................... void blockToSTring(unsigned char block[16]){ 
....................    int i; 
....................    for(i=0;i<16;i++){ 
....................       //sprintf(&str[2*i],"%.2x",(unsigned char)block[i]); 
....................       printf("%.2X ",block[i]); 
....................    } 
....................    //str[16*2]=0; 
....................    printf("\n"); 
....................     
.................... } 
....................  
....................  
.................... void blockToSTringbyte(unsigned char block[8]){ 
....................    int i; 
....................    for(i=0;i<8;i++){ 
....................       //sprintf(&str[2*i],"%.2x",(unsigned char)block[i]); 
....................       printf("%.2X ",block[i]); 
....................    } 
....................    //str[16*2]=0; 
....................    printf("\n"); 
....................     
.................... } 
....................  
.................... int convertdigit(char digit){ 
*
0222:  MOV.B   #FF,W0L
0224:  MOV.B   W0L,87B
....................     
....................    unsigned char value=-1; 
....................    switch (digit){ 
0226:  MOV.B   87A,W0L
0228:  CLR.B   1
022A:  XOR     #30,W0
022C:  BRA     Z,26C
022E:  XOR     #1,W0
0230:  BRA     Z,270
0232:  XOR     #3,W0
0234:  BRA     Z,276
0236:  XOR     #1,W0
0238:  BRA     Z,27C
023A:  XOR     #7,W0
023C:  BRA     Z,282
023E:  XOR     #1,W0
0240:  BRA     Z,288
0242:  XOR     #3,W0
0244:  BRA     Z,28E
0246:  XOR     #1,W0
0248:  BRA     Z,294
024A:  XOR     #F,W0
024C:  BRA     Z,29A
024E:  XOR     #1,W0
0250:  BRA     Z,2A0
0252:  XOR     #78,W0
0254:  BRA     Z,2A6
0256:  XOR     #3,W0
0258:  BRA     Z,2AC
025A:  XOR     #1,W0
025C:  BRA     Z,2B2
025E:  XOR     #7,W0
0260:  BRA     Z,2B8
0262:  XOR     #1,W0
0264:  BRA     Z,2BE
0266:  XOR     #3,W0
0268:  BRA     Z,2C4
026A:  BRA     2CA
....................     
....................    case '0': 
....................       value=0; 
026C:  CLR.B   87B
....................       break; 
026E:  BRA     2CA
....................    case '1': 
....................       value=1; 
0270:  MOV.B   #1,W0L
0272:  MOV.B   W0L,87B
....................       break; 
0274:  BRA     2CA
....................    case '2': 
....................       value=2; 
0276:  MOV.B   #2,W0L
0278:  MOV.B   W0L,87B
....................       break; 
027A:  BRA     2CA
....................    case '3': 
....................       value=3; 
027C:  MOV.B   #3,W0L
027E:  MOV.B   W0L,87B
....................       break; 
0280:  BRA     2CA
....................    case '4': 
....................       value=4; 
0282:  MOV.B   #4,W0L
0284:  MOV.B   W0L,87B
....................       break; 
0286:  BRA     2CA
....................    case '5': 
....................       value=5; 
0288:  MOV.B   #5,W0L
028A:  MOV.B   W0L,87B
....................       break; 
028C:  BRA     2CA
....................    case '6': 
....................       value=6; 
028E:  MOV.B   #6,W0L
0290:  MOV.B   W0L,87B
....................       break; 
0292:  BRA     2CA
....................    case '7': 
....................       value=7; 
0294:  MOV.B   #7,W0L
0296:  MOV.B   W0L,87B
....................       break;       
0298:  BRA     2CA
....................    case '8': 
....................       value=8; 
029A:  MOV.B   #8,W0L
029C:  MOV.B   W0L,87B
....................       break; 
029E:  BRA     2CA
....................    case '9': 
....................       value=9; 
02A0:  MOV.B   #9,W0L
02A2:  MOV.B   W0L,87B
....................       break; 
02A4:  BRA     2CA
....................    case 'A': 
....................       value=10; 
02A6:  MOV.B   #A,W0L
02A8:  MOV.B   W0L,87B
....................       break; 
02AA:  BRA     2CA
....................    case 'B': 
....................       value=11; 
02AC:  MOV.B   #B,W0L
02AE:  MOV.B   W0L,87B
....................       break;    
02B0:  BRA     2CA
....................    case 'C': 
....................       value=12; 
02B2:  MOV.B   #C,W0L
02B4:  MOV.B   W0L,87B
....................       break; 
02B6:  BRA     2CA
....................    case 'D': 
....................       value=13; 
02B8:  MOV.B   #D,W0L
02BA:  MOV.B   W0L,87B
....................       break; 
02BC:  BRA     2CA
....................    case 'E': 
....................       value=14; 
02BE:  MOV.B   #E,W0L
02C0:  MOV.B   W0L,87B
....................       break; 
02C2:  BRA     2CA
....................    case 'F': 
....................       value=15; 
02C4:  MOV.B   #F,W0L
02C6:  MOV.B   W0L,87B
....................       break;    
02C8:  BRA     2CA
....................    } 
....................  
....................    return value; 
02CA:  MOV.B   87B,W0L
02CC:  CLR.B   1
02CE:  MOV     W0,0
.................... } 
02D0:  RETURN  
....................  
.................... /*void setkey(){ 
....................         int i; 
....................         for(i=0;i<16;i++){ 
....................                 K0[i]=0; 
....................                 K1[i]=0; 
....................         } 
.................... }*/ 
....................  
.................... void setkey(){ 
....................     int i; 
....................     /*K0[0]=0x8; 
....................     K0[1]=0x7; 
....................     K0[2]=0x6; 
....................     K0[3]=0x5; 
....................     K0[4]=0x4; 
....................     K0[5]=0x3; 
....................     K0[6]=0x2; 
....................     K0[7]=0x1; 
....................     
....................     K1[0]=0x4; 
....................     K1[1]=0x3; 
....................     K1[2]=0x2; 
....................     K1[3]=0x5; 
....................     K1[4]=0x1; 
....................     K1[5]=0x1; 
....................     K1[6]=0x2; 
....................     K1[7]=0x3;*/    
....................     
....................     K[0]=0x0807060504030201; 
*
0200:  MOV     #201,W4
0202:  MOV     W4,826
0204:  MOV     #403,W4
0206:  MOV     W4,828
0208:  MOV     #605,W4
020A:  MOV     W4,82A
020C:  MOV     #807,W4
020E:  MOV     W4,82C
....................     K[1]=0x0403020501010203;    
0210:  MOV     #203,W4
0212:  MOV     W4,82E
0214:  MOV     #101,W4
0216:  MOV     W4,830
0218:  MOV     #205,W4
021A:  MOV     W4,832
021C:  MOV     #403,W4
021E:  MOV     W4,834
....................     
.................... } 
0220:  RETURN  
....................  
.................... void main() 
.................... { 
*
0CB6:  BSET.B  81.7
0CB8:  MOV     #1F09,W0
0CBA:  MOV     W0,6A4
0CBC:  MOV     #3,W0
0CBE:  MOV     W0,6C8
0CC0:  MOV     #46,W0
0CC2:  MOV.B   W0L,742
0CC4:  MOV     #57,W0
0CC6:  MOV.B   W0L,742
0CC8:  BSET.B  742.6
0CCA:  MOV     #8000,W4
0CCC:  MOV     W4,220
0CCE:  MOV     #400,W4
0CD0:  MOV     W4,222
0CD2:  BCLR.B  220.3
0CD4:  MOV     #19,W4
0CD6:  MOV     W4,228
0CD8:  CLR     836
0CDA:  CLR     838
0CDC:  CLR     83A
0CDE:  CLR     83C
0CE0:  SETM    32C
0CE2:  MOV     #1380,W15
0CE4:  MOV     #13FF,W0
0CE6:  MOV     W0,20
0CE8:  NOP     
*
0CEC:  CLR.B   85F
....................    char buffer[33]; 
....................    char hex[2]; 
....................    int i; 
....................    char temp=0; 
....................    unsigned char block[16];    
....................       
....................    setkey();  
0CEE:  CALL    200
....................       
....................    while(1){ 
....................  
....................          //get the input string 
....................          for (i=0;i<32;i++){ 
0CF2:  CLR     862
0CF4:  MOV     862,W4
0CF6:  MOV     #20,W3
0CF8:  CP      W3,W4
0CFA:  BRA     LE,D28
....................             buffer[i]=getc(); 
0CFC:  MOV     #83E,W4
0CFE:  MOV     862,W3
0D00:  ADD     W3,W4,W5
0D02:  BTSS.B  222.0
0D04:  BRA     D02
0D06:  MOV     226,W0
0D08:  MOV.B   W0L,[W5]
....................             if(buffer[i]=='y'){ 
0D0A:  MOV     #83E,W4
0D0C:  MOV     862,W3
0D0E:  ADD     W3,W4,W0
0D10:  MOV.B   [W0],W4L
0D12:  XOR.B   #79,W4L
0D14:  BRA     NZ,D24
....................                while(kbhit()){ 
0D16:  BTSS.B  222.0
0D18:  BRA     D24
....................                     temp=getc(); 
0D1A:  BTSS.B  222.0
0D1C:  BRA     D1A
0D1E:  MOV     226,W0
0D20:  MOV.B   W0L,85F
....................                } 
0D22:  BRA     D16
....................             } 
....................          } 
0D24:  INC     0862
0D26:  BRA     CF4
....................          buffer[i]=0; 
0D28:  MOV     #83E,W4
0D2A:  MOV     862,W3
0D2C:  ADD     W3,W4,W5
0D2E:  CLR.B   [W5]
....................         
....................          //convert the input string 
....................          for(i=0;i<16;i++){ 
0D30:  CLR     862
0D32:  MOV     862,W4
0D34:  CP      W4,#10
0D36:  BRA     GE,D82
....................             hex[0]=buffer[i*2]; 
0D38:  MOV     862,W4
0D3A:  MUL.UU  W4,#2,W0
0D3C:  MOV     W0,W5
0D3E:  MOV     #83E,W4
0D40:  ADD     W5,W4,W0
0D42:  MOV     860,W4
0D44:  MOV.B   [W0+#0],W4L
0D46:  MOV     W4,860
....................             hex[1]=buffer[i*2+1]; 
0D48:  MOV     862,W4
0D4A:  MUL.UU  W4,#2,W0
0D4C:  MOV     W0,W5
0D4E:  ADD     W5,#1,W5
0D50:  MOV     #83E,W4
0D52:  ADD     W5,W4,W0
0D54:  MOV.B   [W0],W0L
0D56:  MOV.B   W0L,861
....................             if(i<16){ 
0D58:  MOV     862,W4
0D5A:  CP      W4,#10
0D5C:  BRA     GE,D7E
....................                block[i]=convertdigit(hex[1])+16*convertdigit(hex[0]); 
0D5E:  MOV     #864,W4
0D60:  MOV     862,W3
0D62:  ADD     W3,W4,W5
0D64:  MOV.B   861,W0L
0D66:  MOV.B   W0L,87A
0D68:  CALL    222
0D6C:  MOV     W0,W6
0D6E:  MOV.B   860,W0L
0D70:  MOV.B   W0L,87A
0D72:  CALL    222
0D76:  MOV     W0,W4
0D78:  MUL.UU  W4,#10,W0
0D7A:  ADD     W0,W6,W0
0D7C:  MOV.B   W0L,[W5]
....................             } 
....................          } 
0D7E:  INC     0862
0D80:  BRA     D32
....................  
....................          //prints the plain text 
....................          for (i=0;i<16;i++){ 
0D82:  CLR     862
0D84:  MOV     862,W4
0D86:  CP      W4,#10
0D88:  BRA     GE,DA0
....................                printf("%2X", block[i] ); 
0D8A:  MOV     #864,W4
0D8C:  MOV     862,W3
0D8E:  ADD     W3,W4,W0
0D90:  MOV.B   [W0],W5L
0D92:  MOV.B   W5L,W0L
0D94:  CLR.B   1
0D96:  MOV     #702,W1
0D98:  CALL    2D2
....................          } 
0D9C:  INC     0862
0D9E:  BRA     D84
....................        convertback(pt,block); 
0DA0:  MOV     #806,W5
0DA2:  MOV     W5,878
0DA4:  MOV     #864,W4
0DA6:  MOV     W4,87A
0DA8:  CALL    308
....................           
....................          while(1){ 
....................           
....................              if(kbhit()){ 
0DAC:  BTSS.B  222.0
0DAE:  BRA     DD6
....................                temp=getc(); 
0DB0:  BTSS.B  222.0
0DB2:  BRA     DB0
0DB4:  MOV     226,W0
0DB6:  MOV.B   W0L,85F
....................                if(temp=='z'){ 
0DB8:  MOV     85E,W4
0DBA:  LSR     W4,#8,W4
0DBC:  XOR.B   #7A,W4L
0DBE:  BRA     NZ,DC4
....................                   break; 
0DC0:  BRA     DE4
....................                } 
....................                else{ 
0DC2:  BRA     DD4
....................                   while(kbhit()){ 
0DC4:  BTSS.B  222.0
0DC6:  BRA     DD2
....................                      temp=getc(); 
0DC8:  BTSS.B  222.0
0DCA:  BRA     DC8
0DCC:  MOV     226,W0
0DCE:  MOV.B   W0L,85F
....................                   } 
0DD0:  BRA     DC4
....................                   break; 
0DD2:  BRA     DE4
....................                } 
....................              } 
....................              else{ 
0DD4:  BRA     DE2
....................   
....................                //output_high (PIN_B0); 
....................                encrypt(); 
0DD6:  CALL    77E
....................                //output_low (PIN_B0); 
....................                delay_ms(5); 
0DDA:  REPEAT  #E1E
0DDC:  NOP     
0DDE:  REPEAT  #3FFF
0DE0:  NOP     
....................              } 
....................          }    
0DE2:  BRA     DAC
....................   
....................          //prints the cipher text 
....................       convert(block,ct);        
0DE4:  MOV     #816,W5
0DE6:  MOV     #864,W4
0DE8:  MOV     W4,878
0DEA:  MOV     W5,87A
0DEC:  CALL    9F4
....................          for (i=0;i<16;i++){ 
0DF0:  CLR     862
0DF2:  MOV     862,W4
0DF4:  CP      W4,#10
0DF6:  BRA     GE,E0E
....................                printf("%2X", block[i] ); 
0DF8:  MOV     #864,W4
0DFA:  MOV     862,W3
0DFC:  ADD     W3,W4,W0
0DFE:  MOV.B   [W0],W5L
0E00:  MOV.B   W5L,W0L
0E02:  CLR.B   1
0E04:  MOV     #702,W1
0E06:  CALL    2D2
....................          } 
0E0A:  INC     0862
0E0C:  BRA     DF2
....................          delay_ms(5); 
0E0E:  REPEAT  #E1E
0E10:  NOP     
0E12:  REPEAT  #3FFF
0E14:  NOP     
....................    
....................        
....................    } 
0E16:  BRA     CF2
.................... } 
0E18:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 000F   NOWRTB
          H: 0000  
   Word  2L: 0000  
          H: 0000  
   Word  3L: 0007   NOWRTSS NOPROTECT
          H: 0000  
   Word  4L: 0082   PR IESO
          H: 0000  
   Word  5L: 00E5   XT NOOSCIO IOL1WAY
          H: 0000  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: 0000  
   Word  7L: 0017   PUT128 ALTI2C
          H: 0000  
   Word  8L: 00C3   ICSP1 NOJTAG NODEBUG
          H: 0000  
